# coding: utf-8

"""
    LUSID API

    FINBOURNE Technology  # noqa: E501

    Contact: info@finbourne.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, conlist, constr, validator
from lusid.models.aggregation_options import AggregationOptions
from lusid.models.configuration_recipe import ConfigurationRecipe
from lusid.models.market_data_key_rule import MarketDataKeyRule
from lusid.models.market_options import MarketOptions
from lusid.models.pricing_options import PricingOptions
from lusid.models.vendor_model_rule import VendorModelRule

class ConfigurationRecipeSnippet(BaseModel):
    """
    If it is desired to have multiple recipes, there is a strong likelihood that they will share various components.  A configuration recipe snippet allows a user to define a set of rules that can then be included into a parent recipe.  This allows sharing of common blocks of the recipe.                For example, a user might define a set of rules for resolving Fx and then include them into every recipe used firm-wide, thereby  enforcing consistency. As the rules can be permissioned differently using Shrine, it is possible to enable users to   read but not alter such a rule set.                The same applies to a set of pricing rules.                A configuration snippet must only contain one entry from the available set.                 Recipes are compiled from the set of snippets through a model that is analogous to inheritance.  A recipe can have a set of 'parent' recipes from which it inherits. These are specified in the inheritance section of a recipe.  Upon loading, the recipe will fall back on these recipe components for any options or rules that are not explicitly specified in the  named recipe for the request.                This allows control of pricing to be harmonised across a set of desks within an institution. Suppose that, e.g.  there are four desks looking after products under the areas of Fx, Rates, Credit and Exotics.  The model and market data for pricing given asset types would potentially be controlled by the appropriate desk; e.g. rules for Fx market data resolution being  controlled by the Fx desk. The exotics desk would likely depend upon rules for all the other asset classes as well as, say, correlation rules of its own.  It could inherit the market data and model rules from the other desks for finding the appropriate institution-standard data and then overlay that with the correlation rules.                Note that permissioning of the store means that one could decide that only a particular desk or control function could update certain rules. That would assist the abilitiy  to ensure that pricing is performed consistently and provide an audit of changes made to it along with restricting changes to appropriate authorised functions.
    """
    scope: constr(strict=True, max_length=64, min_length=1) = Field(..., description="The scope used when updating or inserting the Configuration Recipe snippet")
    code: constr(strict=True, max_length=64, min_length=1) = Field(..., description="User given string name (code) to identify the recipe.")
    aggregation_options: Optional[AggregationOptions] = Field(None, alias="aggregationOptions")
    model_rules: Optional[conlist(VendorModelRule)] = Field(None, alias="modelRules", description="The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options.")
    pricing_options: Optional[PricingOptions] = Field(None, alias="pricingOptions")
    market_rules: Optional[conlist(MarketDataKeyRule)] = Field(None, alias="marketRules", description="The set of rules that define how to resolve particular use cases. These can be relatively general or specific in nature.  Nominally any number are possible and will be processed in order where applicable. However, there is evidently a potential  for increased computational cost where many rules must be applied to resolve data. Ensuring that portfolios are structured in  such a way as to reduce the number of rules required is therefore sensible.")
    market_options: Optional[MarketOptions] = Field(None, alias="marketOptions")
    recipe: Optional[ConfigurationRecipe] = None
    __properties = ["scope", "code", "aggregationOptions", "modelRules", "pricingOptions", "marketRules", "marketOptions", "recipe"]

    @validator('scope')
    def scope_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^[a-zA-Z0-9\-_]+$", value):
            raise ValueError(r"must validate the regular expression /^[a-zA-Z0-9\-_]+$/")
        return value

    @validator('code')
    def code_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^[a-zA-Z0-9\-_]+$", value):
            raise ValueError(r"must validate the regular expression /^[a-zA-Z0-9\-_]+$/")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> ConfigurationRecipeSnippet:
        """Create an instance of ConfigurationRecipeSnippet from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of aggregation_options
        if self.aggregation_options:
            _dict['aggregationOptions'] = self.aggregation_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in model_rules (list)
        _items = []
        if self.model_rules:
            for _item in self.model_rules:
                if _item:
                    _items.append(_item.to_dict())
            _dict['modelRules'] = _items
        # override the default output from pydantic by calling `to_dict()` of pricing_options
        if self.pricing_options:
            _dict['pricingOptions'] = self.pricing_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in market_rules (list)
        _items = []
        if self.market_rules:
            for _item in self.market_rules:
                if _item:
                    _items.append(_item.to_dict())
            _dict['marketRules'] = _items
        # override the default output from pydantic by calling `to_dict()` of market_options
        if self.market_options:
            _dict['marketOptions'] = self.market_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of recipe
        if self.recipe:
            _dict['recipe'] = self.recipe.to_dict()
        # set to None if model_rules (nullable) is None
        # and __fields_set__ contains the field
        if self.model_rules is None and "model_rules" in self.__fields_set__:
            _dict['modelRules'] = None

        # set to None if market_rules (nullable) is None
        # and __fields_set__ contains the field
        if self.market_rules is None and "market_rules" in self.__fields_set__:
            _dict['marketRules'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> ConfigurationRecipeSnippet:
        """Create an instance of ConfigurationRecipeSnippet from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return ConfigurationRecipeSnippet.parse_obj(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in ConfigurationRecipeSnippet) in the input: " + obj)

        _obj = ConfigurationRecipeSnippet.parse_obj({
            "scope": obj.get("scope"),
            "code": obj.get("code"),
            "aggregation_options": AggregationOptions.from_dict(obj.get("aggregationOptions")) if obj.get("aggregationOptions") is not None else None,
            "model_rules": [VendorModelRule.from_dict(_item) for _item in obj.get("modelRules")] if obj.get("modelRules") is not None else None,
            "pricing_options": PricingOptions.from_dict(obj.get("pricingOptions")) if obj.get("pricingOptions") is not None else None,
            "market_rules": [MarketDataKeyRule.from_dict(_item) for _item in obj.get("marketRules")] if obj.get("marketRules") is not None else None,
            "market_options": MarketOptions.from_dict(obj.get("marketOptions")) if obj.get("marketOptions") is not None else None,
            "recipe": ConfigurationRecipe.from_dict(obj.get("recipe")) if obj.get("recipe") is not None else None
        })
        return _obj

