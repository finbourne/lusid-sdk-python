# coding: utf-8

"""
    LUSID API

    FINBOURNE Technology  # noqa: E501

    Contact: info@finbourne.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional, Union
from pydantic import BaseModel, Field, StrictFloat, StrictInt, constr
from lusid.models.lusid_instrument import LusidInstrument

class WeightedInstrument(BaseModel):
    """
    Specification for a holding or quantity of (weight for) an instrument on a given date.
    """
    quantity: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="The quantity of the instrument that is owned.")
    holding_identifier: Optional[constr(strict=True, max_length=256, min_length=0)] = Field(None, alias="holdingIdentifier", description="Identifier for the instrument.  For a single, unique trade or transaction this can be thought of as equivalent to the transaction identifier, or  a composite of the sub-holding keys for a regular sub-holding. When there are multiple transactions sharing the same underlying instrument  such as purchase of shares on multiple dates where tax implications are different this would not be the case.    In an inlined aggregation request if this is wanted to identify a line item, it can be specified in the set of aggregation keys given on the aggregation  request that accompanies the set of weighted instruments.")
    instrument: Optional[LusidInstrument] = None
    __properties = ["quantity", "holdingIdentifier", "instrument"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> WeightedInstrument:
        """Create an instance of WeightedInstrument from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of instrument
        if self.instrument:
            _dict['instrument'] = self.instrument.to_dict()
        # set to None if holding_identifier (nullable) is None
        # and __fields_set__ contains the field
        if self.holding_identifier is None and "holding_identifier" in self.__fields_set__:
            _dict['holdingIdentifier'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> WeightedInstrument:
        """Create an instance of WeightedInstrument from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return WeightedInstrument.parse_obj(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in WeightedInstrument) in the input: " + obj)

        _obj = WeightedInstrument.parse_obj({
            "quantity": obj.get("quantity"),
            "holding_identifier": obj.get("holdingIdentifier"),
            "instrument": LusidInstrument.from_dict(obj.get("instrument")) if obj.get("instrument") is not None else None
        })
        return _obj

