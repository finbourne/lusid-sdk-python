# coding: utf-8

"""
    LUSID API

    FINBOURNE Technology  # noqa: E501

    Contact: info@finbourne.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional
from pydantic import BaseModel, Field, StrictStr, constr

class DependencySourceFilter(BaseModel):
    """
    Encapsulates parts of a market data rule relating not to the nature of the market data requested, but rather the nature of the thing (instrument/model) that is requesting it.  In the first instance, this includes the instrument type, asset class, and the currency of the underlying instrument.  This can be used to differentiate requests for market data according to the source of the request. See MarketDataSpecificRule.
    """
    instrument_type: Optional[constr(strict=True, max_length=32, min_length=0)] = Field(None, alias="instrumentType", description="Specify that a rule should only apply if the market data is requested by an instrument of a given instrument type.  If null, then no filtering on instrument type is applied.")
    asset_class: Optional[constr(strict=True, max_length=32, min_length=0)] = Field(None, alias="assetClass", description="Specify that a rule should only apply if the market data is requested by an instrument of a given asset class.  If null, then no filtering on asset class is applied.")
    dom_ccy: Optional[StrictStr] = Field(None, alias="domCcy", description="Specify that a rule should only apply if the market data is requested by an instrument with a given domestic currency.  If null, then no filtering on currency is applied.")
    __properties = ["instrumentType", "assetClass", "domCcy"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> DependencySourceFilter:
        """Create an instance of DependencySourceFilter from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # set to None if instrument_type (nullable) is None
        # and __fields_set__ contains the field
        if self.instrument_type is None and "instrument_type" in self.__fields_set__:
            _dict['instrumentType'] = None

        # set to None if asset_class (nullable) is None
        # and __fields_set__ contains the field
        if self.asset_class is None and "asset_class" in self.__fields_set__:
            _dict['assetClass'] = None

        # set to None if dom_ccy (nullable) is None
        # and __fields_set__ contains the field
        if self.dom_ccy is None and "dom_ccy" in self.__fields_set__:
            _dict['domCcy'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> DependencySourceFilter:
        """Create an instance of DependencySourceFilter from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return DependencySourceFilter.parse_obj(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in DependencySourceFilter) in the input: " + obj)

        _obj = DependencySourceFilter.parse_obj({
            "instrument_type": obj.get("instrumentType"),
            "asset_class": obj.get("assetClass"),
            "dom_ccy": obj.get("domCcy")
        })
        return _obj

